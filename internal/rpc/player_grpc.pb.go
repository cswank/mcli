// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// DownloaderClient is the client API for Downloader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DownloaderClient interface {
	Download(ctx context.Context, in *Request, opts ...grpc.CallOption) (Downloader_DownloadClient, error)
}

type downloaderClient struct {
	cc grpc.ClientConnInterface
}

func NewDownloaderClient(cc grpc.ClientConnInterface) DownloaderClient {
	return &downloaderClient{cc}
}

func (c *downloaderClient) Download(ctx context.Context, in *Request, opts ...grpc.CallOption) (Downloader_DownloadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Downloader_serviceDesc.Streams[0], "/rpc.Downloader/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &downloaderDownloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Downloader_DownloadClient interface {
	Recv() (*Progress, error)
	grpc.ClientStream
}

type downloaderDownloadClient struct {
	grpc.ClientStream
}

func (x *downloaderDownloadClient) Recv() (*Progress, error) {
	m := new(Progress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DownloaderServer is the server API for Downloader service.
// All implementations must embed UnimplementedDownloaderServer
// for forward compatibility
type DownloaderServer interface {
	Download(*Request, Downloader_DownloadServer) error
	mustEmbedUnimplementedDownloaderServer()
}

// UnimplementedDownloaderServer must be embedded to have forward compatible implementations.
type UnimplementedDownloaderServer struct {
}

func (UnimplementedDownloaderServer) Download(*Request, Downloader_DownloadServer) error {
	return status.Errorf(codes.Unimplemented, "method Download not implemented")
}
func (UnimplementedDownloaderServer) mustEmbedUnimplementedDownloaderServer() {}

// UnsafeDownloaderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DownloaderServer will
// result in compilation errors.
type UnsafeDownloaderServer interface {
	mustEmbedUnimplementedDownloaderServer()
}

func RegisterDownloaderServer(s grpc.ServiceRegistrar, srv DownloaderServer) {
	s.RegisterService(&_Downloader_serviceDesc, srv)
}

func _Downloader_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DownloaderServer).Download(m, &downloaderDownloadServer{stream})
}

type Downloader_DownloadServer interface {
	Send(*Progress) error
	grpc.ServerStream
}

type downloaderDownloadServer struct {
	grpc.ServerStream
}

func (x *downloaderDownloadServer) Send(m *Progress) error {
	return x.ServerStream.SendMsg(m)
}

var _Downloader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Downloader",
	HandlerType: (*DownloaderServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Download",
			Handler:       _Downloader_Download_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "player.proto",
}

// HistoryClient is the client API for History service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HistoryClient interface {
	Fetch(ctx context.Context, in *Page, opts ...grpc.CallOption) (*Results, error)
	Save(ctx context.Context, in *Result, opts ...grpc.CallOption) (*Empty, error)
}

type historyClient struct {
	cc grpc.ClientConnInterface
}

func NewHistoryClient(cc grpc.ClientConnInterface) HistoryClient {
	return &historyClient{cc}
}

func (c *historyClient) Fetch(ctx context.Context, in *Page, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.History/Fetch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyClient) Save(ctx context.Context, in *Result, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.History/Save", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HistoryServer is the server API for History service.
// All implementations must embed UnimplementedHistoryServer
// for forward compatibility
type HistoryServer interface {
	Fetch(context.Context, *Page) (*Results, error)
	Save(context.Context, *Result) (*Empty, error)
	mustEmbedUnimplementedHistoryServer()
}

// UnimplementedHistoryServer must be embedded to have forward compatible implementations.
type UnimplementedHistoryServer struct {
}

func (UnimplementedHistoryServer) Fetch(context.Context, *Page) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fetch not implemented")
}
func (UnimplementedHistoryServer) Save(context.Context, *Result) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedHistoryServer) mustEmbedUnimplementedHistoryServer() {}

// UnsafeHistoryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HistoryServer will
// result in compilation errors.
type UnsafeHistoryServer interface {
	mustEmbedUnimplementedHistoryServer()
}

func RegisterHistoryServer(s grpc.ServiceRegistrar, srv HistoryServer) {
	s.RegisterService(&_History_serviceDesc, srv)
}

func _History_Fetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).Fetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.History/Fetch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).Fetch(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _History_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Result)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.History/Save",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).Save(ctx, req.(*Result))
	}
	return interceptor(ctx, in, info, handler)
}

var _History_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.History",
	HandlerType: (*HistoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Fetch",
			Handler:    _History_Fetch_Handler,
		},
		{
			MethodName: "Save",
			Handler:    _History_Save_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "player.proto",
}

// PlayerClient is the client API for Player service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PlayerClient interface {
	Play(ctx context.Context, in *Result, opts ...grpc.CallOption) (*Empty, error)
	PlayAlbum(ctx context.Context, in *Results, opts ...grpc.CallOption) (*Empty, error)
	Volume(ctx context.Context, in *Float, opts ...grpc.CallOption) (*Float, error)
	Pause(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	FastForward(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	Seek(ctx context.Context, in *Int, opts ...grpc.CallOption) (*Empty, error)
	Rewind(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	Queue(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Results, error)
	RemoveFromQueue(ctx context.Context, in *Ints, opts ...grpc.CallOption) (*Results, error)
	NextSong(ctx context.Context, in *String, opts ...grpc.CallOption) (Player_NextSongClient, error)
	PlayProgress(ctx context.Context, in *String, opts ...grpc.CallOption) (Player_PlayProgressClient, error)
	DownloadProgress(ctx context.Context, in *String, opts ...grpc.CallOption) (Player_DownloadProgressClient, error)
	Done(ctx context.Context, in *String, opts ...grpc.CallOption) (*Empty, error)
	Close(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type playerClient struct {
	cc grpc.ClientConnInterface
}

func NewPlayerClient(cc grpc.ClientConnInterface) PlayerClient {
	return &playerClient{cc}
}

func (c *playerClient) Play(ctx context.Context, in *Result, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Player/Play", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) PlayAlbum(ctx context.Context, in *Results, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Player/PlayAlbum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) Volume(ctx context.Context, in *Float, opts ...grpc.CallOption) (*Float, error) {
	out := new(Float)
	err := c.cc.Invoke(ctx, "/rpc.Player/Volume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) Pause(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Player/Pause", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) FastForward(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Player/FastForward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) Seek(ctx context.Context, in *Int, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Player/Seek", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) Rewind(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Player/Rewind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) Queue(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Player/Queue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) RemoveFromQueue(ctx context.Context, in *Ints, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Player/RemoveFromQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) NextSong(ctx context.Context, in *String, opts ...grpc.CallOption) (Player_NextSongClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Player_serviceDesc.Streams[0], "/rpc.Player/NextSong", opts...)
	if err != nil {
		return nil, err
	}
	x := &playerNextSongClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Player_NextSongClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type playerNextSongClient struct {
	grpc.ClientStream
}

func (x *playerNextSongClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *playerClient) PlayProgress(ctx context.Context, in *String, opts ...grpc.CallOption) (Player_PlayProgressClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Player_serviceDesc.Streams[1], "/rpc.Player/PlayProgress", opts...)
	if err != nil {
		return nil, err
	}
	x := &playerPlayProgressClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Player_PlayProgressClient interface {
	Recv() (*Progress, error)
	grpc.ClientStream
}

type playerPlayProgressClient struct {
	grpc.ClientStream
}

func (x *playerPlayProgressClient) Recv() (*Progress, error) {
	m := new(Progress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *playerClient) DownloadProgress(ctx context.Context, in *String, opts ...grpc.CallOption) (Player_DownloadProgressClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Player_serviceDesc.Streams[2], "/rpc.Player/DownloadProgress", opts...)
	if err != nil {
		return nil, err
	}
	x := &playerDownloadProgressClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Player_DownloadProgressClient interface {
	Recv() (*Progress, error)
	grpc.ClientStream
}

type playerDownloadProgressClient struct {
	grpc.ClientStream
}

func (x *playerDownloadProgressClient) Recv() (*Progress, error) {
	m := new(Progress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *playerClient) Done(ctx context.Context, in *String, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Player/Done", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *playerClient) Close(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Player/Close", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlayerServer is the server API for Player service.
// All implementations must embed UnimplementedPlayerServer
// for forward compatibility
type PlayerServer interface {
	Play(context.Context, *Result) (*Empty, error)
	PlayAlbum(context.Context, *Results) (*Empty, error)
	Volume(context.Context, *Float) (*Float, error)
	Pause(context.Context, *Empty) (*Empty, error)
	FastForward(context.Context, *Empty) (*Empty, error)
	Seek(context.Context, *Int) (*Empty, error)
	Rewind(context.Context, *Empty) (*Empty, error)
	Queue(context.Context, *Empty) (*Results, error)
	RemoveFromQueue(context.Context, *Ints) (*Results, error)
	NextSong(*String, Player_NextSongServer) error
	PlayProgress(*String, Player_PlayProgressServer) error
	DownloadProgress(*String, Player_DownloadProgressServer) error
	Done(context.Context, *String) (*Empty, error)
	Close(context.Context, *Empty) (*Empty, error)
	mustEmbedUnimplementedPlayerServer()
}

// UnimplementedPlayerServer must be embedded to have forward compatible implementations.
type UnimplementedPlayerServer struct {
}

func (UnimplementedPlayerServer) Play(context.Context, *Result) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Play not implemented")
}
func (UnimplementedPlayerServer) PlayAlbum(context.Context, *Results) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayAlbum not implemented")
}
func (UnimplementedPlayerServer) Volume(context.Context, *Float) (*Float, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Volume not implemented")
}
func (UnimplementedPlayerServer) Pause(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (UnimplementedPlayerServer) FastForward(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FastForward not implemented")
}
func (UnimplementedPlayerServer) Seek(context.Context, *Int) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seek not implemented")
}
func (UnimplementedPlayerServer) Rewind(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rewind not implemented")
}
func (UnimplementedPlayerServer) Queue(context.Context, *Empty) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Queue not implemented")
}
func (UnimplementedPlayerServer) RemoveFromQueue(context.Context, *Ints) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFromQueue not implemented")
}
func (UnimplementedPlayerServer) NextSong(*String, Player_NextSongServer) error {
	return status.Errorf(codes.Unimplemented, "method NextSong not implemented")
}
func (UnimplementedPlayerServer) PlayProgress(*String, Player_PlayProgressServer) error {
	return status.Errorf(codes.Unimplemented, "method PlayProgress not implemented")
}
func (UnimplementedPlayerServer) DownloadProgress(*String, Player_DownloadProgressServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadProgress not implemented")
}
func (UnimplementedPlayerServer) Done(context.Context, *String) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Done not implemented")
}
func (UnimplementedPlayerServer) Close(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedPlayerServer) mustEmbedUnimplementedPlayerServer() {}

// UnsafePlayerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PlayerServer will
// result in compilation errors.
type UnsafePlayerServer interface {
	mustEmbedUnimplementedPlayerServer()
}

func RegisterPlayerServer(s grpc.ServiceRegistrar, srv PlayerServer) {
	s.RegisterService(&_Player_serviceDesc, srv)
}

func _Player_Play_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Result)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).Play(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/Play",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).Play(ctx, req.(*Result))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_PlayAlbum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Results)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).PlayAlbum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/PlayAlbum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).PlayAlbum(ctx, req.(*Results))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_Volume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Float)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).Volume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/Volume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).Volume(ctx, req.(*Float))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/Pause",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).Pause(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_FastForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).FastForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/FastForward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).FastForward(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_Seek_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).Seek(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/Seek",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).Seek(ctx, req.(*Int))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_Rewind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).Rewind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/Rewind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).Rewind(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_Queue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).Queue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/Queue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).Queue(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_RemoveFromQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).RemoveFromQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/RemoveFromQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).RemoveFromQueue(ctx, req.(*Ints))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_NextSong_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(String)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PlayerServer).NextSong(m, &playerNextSongServer{stream})
}

type Player_NextSongServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type playerNextSongServer struct {
	grpc.ServerStream
}

func (x *playerNextSongServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _Player_PlayProgress_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(String)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PlayerServer).PlayProgress(m, &playerPlayProgressServer{stream})
}

type Player_PlayProgressServer interface {
	Send(*Progress) error
	grpc.ServerStream
}

type playerPlayProgressServer struct {
	grpc.ServerStream
}

func (x *playerPlayProgressServer) Send(m *Progress) error {
	return x.ServerStream.SendMsg(m)
}

func _Player_DownloadProgress_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(String)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PlayerServer).DownloadProgress(m, &playerDownloadProgressServer{stream})
}

type Player_DownloadProgressServer interface {
	Send(*Progress) error
	grpc.ServerStream
}

type playerDownloadProgressServer struct {
	grpc.ServerStream
}

func (x *playerDownloadProgressServer) Send(m *Progress) error {
	return x.ServerStream.SendMsg(m)
}

func _Player_Done_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).Done(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/Done",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).Done(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

func _Player_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlayerServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Player/Close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlayerServer).Close(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Player_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Player",
	HandlerType: (*PlayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Play",
			Handler:    _Player_Play_Handler,
		},
		{
			MethodName: "PlayAlbum",
			Handler:    _Player_PlayAlbum_Handler,
		},
		{
			MethodName: "Volume",
			Handler:    _Player_Volume_Handler,
		},
		{
			MethodName: "Pause",
			Handler:    _Player_Pause_Handler,
		},
		{
			MethodName: "FastForward",
			Handler:    _Player_FastForward_Handler,
		},
		{
			MethodName: "Seek",
			Handler:    _Player_Seek_Handler,
		},
		{
			MethodName: "Rewind",
			Handler:    _Player_Rewind_Handler,
		},
		{
			MethodName: "Queue",
			Handler:    _Player_Queue_Handler,
		},
		{
			MethodName: "RemoveFromQueue",
			Handler:    _Player_RemoveFromQueue_Handler,
		},
		{
			MethodName: "Done",
			Handler:    _Player_Done_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _Player_Close_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NextSong",
			Handler:       _Player_NextSong_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PlayProgress",
			Handler:       _Player_PlayProgress_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DownloadProgress",
			Handler:       _Player_DownloadProgress_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "player.proto",
}

// FetcherClient is the client API for Fetcher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FetcherClient interface {
	Name(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*String, error)
	Login(ctx context.Context, in *UsernamePassword, opts ...grpc.CallOption) (*Empty, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Bool, error)
	AlbumLink(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*String, error)
	FindArtist(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error)
	FindAlbum(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error)
	FindTrack(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error)
	GetAlbum(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error)
	GetArtistAlbums(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error)
	GetArtistTracks(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error)
	GetPlaylists(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Results, error)
	GetPlaylist(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error)
	Import(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Fetcher_ImportClient, error)
}

type fetcherClient struct {
	cc grpc.ClientConnInterface
}

func NewFetcherClient(cc grpc.ClientConnInterface) FetcherClient {
	return &fetcherClient{cc}
}

func (c *fetcherClient) Name(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*String, error) {
	out := new(String)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/Name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) Login(ctx context.Context, in *UsernamePassword, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Bool, error) {
	out := new(Bool)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) AlbumLink(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*String, error) {
	out := new(String)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/AlbumLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) FindArtist(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/FindArtist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) FindAlbum(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/FindAlbum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) FindTrack(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/FindTrack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) GetAlbum(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/GetAlbum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) GetArtistAlbums(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/GetArtistAlbums", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) GetArtistTracks(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/GetArtistTracks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) GetPlaylists(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/GetPlaylists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) GetPlaylist(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Results, error) {
	out := new(Results)
	err := c.cc.Invoke(ctx, "/rpc.Fetcher/GetPlaylist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fetcherClient) Import(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Fetcher_ImportClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Fetcher_serviceDesc.Streams[0], "/rpc.Fetcher/Import", opts...)
	if err != nil {
		return nil, err
	}
	x := &fetcherImportClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Fetcher_ImportClient interface {
	Recv() (*Progress, error)
	grpc.ClientStream
}

type fetcherImportClient struct {
	grpc.ClientStream
}

func (x *fetcherImportClient) Recv() (*Progress, error) {
	m := new(Progress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FetcherServer is the server API for Fetcher service.
// All implementations must embed UnimplementedFetcherServer
// for forward compatibility
type FetcherServer interface {
	Name(context.Context, *Empty) (*String, error)
	Login(context.Context, *UsernamePassword) (*Empty, error)
	Ping(context.Context, *Empty) (*Bool, error)
	AlbumLink(context.Context, *Empty) (*String, error)
	FindArtist(context.Context, *Request) (*Results, error)
	FindAlbum(context.Context, *Request) (*Results, error)
	FindTrack(context.Context, *Request) (*Results, error)
	GetAlbum(context.Context, *Request) (*Results, error)
	GetArtistAlbums(context.Context, *Request) (*Results, error)
	GetArtistTracks(context.Context, *Request) (*Results, error)
	GetPlaylists(context.Context, *Empty) (*Results, error)
	GetPlaylist(context.Context, *Request) (*Results, error)
	Import(*Empty, Fetcher_ImportServer) error
	mustEmbedUnimplementedFetcherServer()
}

// UnimplementedFetcherServer must be embedded to have forward compatible implementations.
type UnimplementedFetcherServer struct {
}

func (UnimplementedFetcherServer) Name(context.Context, *Empty) (*String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedFetcherServer) Login(context.Context, *UsernamePassword) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedFetcherServer) Ping(context.Context, *Empty) (*Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedFetcherServer) AlbumLink(context.Context, *Empty) (*String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlbumLink not implemented")
}
func (UnimplementedFetcherServer) FindArtist(context.Context, *Request) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindArtist not implemented")
}
func (UnimplementedFetcherServer) FindAlbum(context.Context, *Request) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindAlbum not implemented")
}
func (UnimplementedFetcherServer) FindTrack(context.Context, *Request) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindTrack not implemented")
}
func (UnimplementedFetcherServer) GetAlbum(context.Context, *Request) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAlbum not implemented")
}
func (UnimplementedFetcherServer) GetArtistAlbums(context.Context, *Request) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArtistAlbums not implemented")
}
func (UnimplementedFetcherServer) GetArtistTracks(context.Context, *Request) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArtistTracks not implemented")
}
func (UnimplementedFetcherServer) GetPlaylists(context.Context, *Empty) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlaylists not implemented")
}
func (UnimplementedFetcherServer) GetPlaylist(context.Context, *Request) (*Results, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlaylist not implemented")
}
func (UnimplementedFetcherServer) Import(*Empty, Fetcher_ImportServer) error {
	return status.Errorf(codes.Unimplemented, "method Import not implemented")
}
func (UnimplementedFetcherServer) mustEmbedUnimplementedFetcherServer() {}

// UnsafeFetcherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FetcherServer will
// result in compilation errors.
type UnsafeFetcherServer interface {
	mustEmbedUnimplementedFetcherServer()
}

func RegisterFetcherServer(s grpc.ServiceRegistrar, srv FetcherServer) {
	s.RegisterService(&_Fetcher_serviceDesc, srv)
}

func _Fetcher_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/Name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).Name(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsernamePassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).Login(ctx, req.(*UsernamePassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_AlbumLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).AlbumLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/AlbumLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).AlbumLink(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_FindArtist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).FindArtist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/FindArtist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).FindArtist(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_FindAlbum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).FindAlbum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/FindAlbum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).FindAlbum(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_FindTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).FindTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/FindTrack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).FindTrack(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_GetAlbum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).GetAlbum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/GetAlbum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).GetAlbum(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_GetArtistAlbums_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).GetArtistAlbums(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/GetArtistAlbums",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).GetArtistAlbums(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_GetArtistTracks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).GetArtistTracks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/GetArtistTracks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).GetArtistTracks(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_GetPlaylists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).GetPlaylists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/GetPlaylists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).GetPlaylists(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_GetPlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FetcherServer).GetPlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Fetcher/GetPlaylist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FetcherServer).GetPlaylist(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fetcher_Import_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FetcherServer).Import(m, &fetcherImportServer{stream})
}

type Fetcher_ImportServer interface {
	Send(*Progress) error
	grpc.ServerStream
}

type fetcherImportServer struct {
	grpc.ServerStream
}

func (x *fetcherImportServer) Send(m *Progress) error {
	return x.ServerStream.SendMsg(m)
}

var _Fetcher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Fetcher",
	HandlerType: (*FetcherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Name",
			Handler:    _Fetcher_Name_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Fetcher_Login_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Fetcher_Ping_Handler,
		},
		{
			MethodName: "AlbumLink",
			Handler:    _Fetcher_AlbumLink_Handler,
		},
		{
			MethodName: "FindArtist",
			Handler:    _Fetcher_FindArtist_Handler,
		},
		{
			MethodName: "FindAlbum",
			Handler:    _Fetcher_FindAlbum_Handler,
		},
		{
			MethodName: "FindTrack",
			Handler:    _Fetcher_FindTrack_Handler,
		},
		{
			MethodName: "GetAlbum",
			Handler:    _Fetcher_GetAlbum_Handler,
		},
		{
			MethodName: "GetArtistAlbums",
			Handler:    _Fetcher_GetArtistAlbums_Handler,
		},
		{
			MethodName: "GetArtistTracks",
			Handler:    _Fetcher_GetArtistTracks_Handler,
		},
		{
			MethodName: "GetPlaylists",
			Handler:    _Fetcher_GetPlaylists_Handler,
		},
		{
			MethodName: "GetPlaylist",
			Handler:    _Fetcher_GetPlaylist_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Import",
			Handler:       _Fetcher_Import_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "player.proto",
}
